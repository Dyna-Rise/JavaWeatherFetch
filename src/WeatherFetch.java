/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/GUIForms/JFrame.java to edit this template
 */

/**
 *
 * @author dynarise
 */
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.net.HttpURLConnection;
import java.net.URL;

public class WeatherFetch extends javax.swing.JFrame {
    
    private static final java.util.logging.Logger logger = java.util.logging.Logger.getLogger(WeatherFetch.class.getName());

    /**
     * Creates new form WeatherFetch
     */
    public WeatherFetch() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jLabel1 = new javax.swing.JLabel();
        comboLocation = new javax.swing.JComboBox<>();
        btnGetWeather = new javax.swing.JButton();
        labelWeather = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        jLabel1.setFont(new java.awt.Font("Yu Gothic UI", 0, 18)); // NOI18N
        jLabel1.setForeground(new java.awt.Color(255, 255, 255));
        jLabel1.setText("都市を選択してください");
        jLabel1.setToolTipText("");

        comboLocation.setFont(new java.awt.Font("Yu Gothic UI", 0, 18)); // NOI18N
        comboLocation.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] { "Tokyo", "Osaka" }));

        btnGetWeather.setText("天気確認");
        btnGetWeather.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnGetWeatherActionPerformed(evt);
            }
        });

        labelWeather.setFont(new java.awt.Font("Yu Gothic UI", 0, 18)); // NOI18N
        labelWeather.setForeground(new java.awt.Color(255, 255, 0));
        labelWeather.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        labelWeather.setText("ここに天気が出ます");
        labelWeather.setToolTipText("");

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addGroup(layout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(labelWeather, javax.swing.GroupLayout.PREFERRED_SIZE, 305, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(javax.swing.GroupLayout.Alignment.LEADING, layout.createSequentialGroup()
                        .addGap(32, 32, 32)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addComponent(btnGetWeather)
                            .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                .addComponent(comboLocation, javax.swing.GroupLayout.PREFERRED_SIZE, 305, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addComponent(jLabel1)))))
                .addContainerGap(63, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(25, 25, 25)
                .addComponent(jLabel1)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(comboLocation, javax.swing.GroupLayout.PREFERRED_SIZE, 46, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addComponent(btnGetWeather)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 51, Short.MAX_VALUE)
                .addComponent(labelWeather)
                .addGap(78, 78, 78))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void btnGetWeatherActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnGetWeatherActionPerformed
        // TODO add your handling code here:
        GetWeather(); //自作メソッド       
    }//GEN-LAST:event_btnGetWeatherActionPerformed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ReflectiveOperationException | javax.swing.UnsupportedLookAndFeelException ex) {
            logger.log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(() -> new WeatherFetch().setVisible(true));
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton btnGetWeather;
    private javax.swing.JComboBox<String> comboLocation;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel labelWeather;
    // End of variables declaration//GEN-END:variables

    private void GetWeather(){
        //特定のサイトのURLを用意
        //都市情報をコンボボックスから取得
        String city = comboLocation.getSelectedItem().toString();
        //必要なAPIキー
        String apiKey = "a4cec97dcaf5d01939bc2ca7cef15e9f";
        //必要なサイトURLにまとめる
        String apiUrl = "https://api.openweathermap.org/data/2.5/weather?q=" + city
                + ",jp&appid=" + apiKey + "&lang=ja&units=metric";

        try{
            //URLオブジェクトを生成（特定の文字列からどれがプロトコル、どれがホストで～）
            URL url = new URL(apiUrl);
            //単に通信しています
            //HTTP通信であるということを明確にした型として接続情報を取得
            HttpURLConnection conn = (HttpURLConnection)url.openConnection();
            conn.setRequestMethod("GET"); //サイトの本文情報をGET方式で獲得
            
            //getInputStream バイトコードとして取り出し
            //UTF-8情報に変換する InputStreamReader
            //バッファーとして格納
            BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream(),"UTF-8"));
            
            StringBuilder response = new StringBuilder();
            String line;
            
            //バッファーに格納された複数行にわたる情報を一行ずつ抽出
            while((line = reader.readLine()) != null){
                //抽出した一行をresponseに格納していく
                response.append(line);
            }
            
            //StringBuilderの機能を活用して集めたresponseの内容を文字列に変換
            //文字列 res変数にサイトの本文情報を獲得
            String res = response.toString();
            
            //天気を取得 (自作メソッドを使う）
            String weather = parseWeather(res);
            
            //取得した天気をラベルに貼る
            labelWeather.setText(city + "の天気は" + weather + "です");
            
        } catch (Exception ex){
            ex.printStackTrace();
            labelWeather.setText("天気の取得に失敗しました");
        }
            
    }
    
    //引数に与えられた情報から天気だけを抽出するメソッド
    private String parseWeather(String res){
        String keyword = "\"description\":\"";
        
        //keywordがあった場合、何番目の文字から始まるのか番号取得（なかったら-1)
        int index  = res.indexOf(keyword);
        if(index != -1){
            //キーワードの先頭番号からキーワードの文字数分だけ進めた場所がスタート
            int start = index + keyword.length();
            //スタート位置からはじめに"がくるまでの番号 （なかったら-1)
            int end = res.indexOf("\"",start);
            if(end != -1){
                //startからendまでの文字列を切り抜く
                return res.substring(start,end);
            }
        }        
        return "不明";               
    }

}
